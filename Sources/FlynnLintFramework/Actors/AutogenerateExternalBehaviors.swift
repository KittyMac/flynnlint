//
//  main.swift
//  flynnlint
//
//  Created by Rocco Bowling on 5/29/20.
//  Copyright Â© 2020 Rocco Bowling. All rights reserved.
//

// swiftlint:disable function_body_length
// swiftlint:disable cyclomatic_complexity
// swiftlint:disable line_length

import Foundation
import SourceKittenFramework
import Flynn

class AutogenerateExternalBehaviors: Actor, Flowable {
    // input: an AST and one syntax structure
    // output: an AST and one syntax structure
    var safeFlowable = FlowableState()

    private func _beFlow(_ args: FlowableArgs) {
        if args.isEmpty == false {
            let ast: AST = args[x:0]
            let syntax: FileSyntax = args[x:1]
            let fileOnly: Bool = args[x:2]

            if fileOnly {

                var numOfExtensions = 0
                var fileString = syntax.file.contents
                let fileMarker = "\n// MARK: - Autogenerated by FlynnLint\n"

                let parts = fileString.components(separatedBy: fileMarker)
                fileString = parts[0]

                let previousExtensionString = parts.count > 1 ? parts[1] : ""

                fileString.append(fileMarker)

                var newExtensionString = ""
                newExtensionString.append("// Contents of file after this marker will be overwritten as needed\n")

                // 1. run over all actor definitions in this file
                for (_, actorSyntax) in ast.classes.sorted(by: { $0.0 > $1.0 }) {
                    if  actorSyntax.file == syntax.file &&
                        ast.isActor(actorSyntax) {

                        let (internals, _) = ast.getBehaviorsForActor(actorSyntax)

                        numOfExtensions += 1

                        let fullActorName = ast.getFullName(syntax, actorSyntax)

                        newExtensionString.append("\n")
                        newExtensionString.append("extension \(fullActorName) {\n\n")
                        for behavior in internals {
                            if let fullName = behavior.function.structure.name {

                                // Note: The information we need comes from two places:
                                // 1. behavior.function.structure.name is formatted like this:
                                //    _beSetCoreAffinity(theAffinity:arg2:)

                                var name = ""
                                var parameterLabels: [String] = []

                                let regex = #"(.*)\(([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?([\w\d]*:)?\)"#
                                fullName.matches(regex) { (_, groups) in
                                    // ["_beSetCoreAffinity(theAffinity:arg2:)", "_beSetCoreAffinity", "theAffinity:", "arg2:"]

                                    name = groups[1]
                                    if name.hasPrefix("_") {
                                        name.removeFirst()
                                    }

                                    for idx in 2..<groups.count {
                                        var label = groups[idx]
                                        if label.hasSuffix(":") {
                                            label.removeLast()
                                        }
                                        parameterLabels.append(label)
                                    }
                                }

                                // 2. the names and type of the parameters are in the substructures
                                newExtensionString.append("    @discardableResult\n")
                                newExtensionString.append("    public func \(name)(")
                                if parameterLabels.count > 0 {
                                    if let parameters = behavior.function.structure.substructure {
                                        var idx = 0
                                        for parameter in parameters where parameter.kind == .varParameter {
                                            let label = parameterLabels[idx]

                                            if let typename = parameter.typename,
                                                let name = parameter.name {
                                                let typename = ast.getFullName(syntax, typename)
                                                newExtensionString.append("\(label) \(name): \(typename), ")
                                            }
                                            idx += 1
                                        }
                                        newExtensionString.removeLast()
                                        newExtensionString.removeLast()
                                    }
                                }
                                newExtensionString.append(") -> Self {\n")

                                if parameterLabels.count == 0 {
                                    newExtensionString.append("        unsafeSend(_\(name))\n")
                                } else {
                                    newExtensionString.append("        unsafeSend { self._\(name)(")

                                    if let parameters = behavior.function.structure.substructure {
                                        var idx = 0
                                        for parameter in parameters where parameter.kind == .varParameter {
                                            let label = parameterLabels[idx]
                                            if label == "_" {
                                                newExtensionString.append("\(parameter.name!), ")
                                            } else {
                                                newExtensionString.append("\(label): \(parameter.name!), ")
                                            }
                                            idx += 1
                                        }
                                        newExtensionString.removeLast()
                                        newExtensionString.removeLast()
                                    }
                                    newExtensionString.append(") }\n")
                                }
                                newExtensionString.append("        return self\n")
                                newExtensionString.append("    }\n")
                            }
                        }

                        newExtensionString.append("\n}\n")
                    }
                }

                // Four scenarios we want to make sure we handle:
                // - Actor in file with no previous FlynnLint generation
                // - Actor in file with existing FlynnLint generation, but does not need updated (no changes)
                // - Actor in file with existing FlynnLint generation, but does need updated
                // - Actor in file, but an existing FlynnLint generation.
                if  (numOfExtensions > 0 && previousExtensionString == "") ||
                    (numOfExtensions > 0 && newExtensionString != previousExtensionString) ||
                    (numOfExtensions == 0 && previousExtensionString != "") {

                    fileString.append(newExtensionString)

                    if let outputFilePath = syntax.file.path {
                        try? fileString.write(toFile: outputFilePath, atomically: false, encoding: .utf8)
                    }
                }

            }
        }

        self.safeFlowToNextTarget(args)

    }
}

extension AutogenerateExternalBehaviors {
    func beFlow(_ args: FlowableArgs) {
        unsafeSend {
            self._beFlow(args)
        }
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension AutogenerateExternalBehaviors {

    @discardableResult
    public func beFlow(_ args: FlowableArgs) -> Self {
        unsafeSend { self._beFlow(args) }
        return self
    }

}
